---
title: "Supermarket Sweep"
author: "Adam Profili, Brynn Schneberger"
date: "4/25/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# a.

We start first with a list of the nodes given in the Supermarket Sweep.csv file, each wrapped in an Item object that holds its x, y, and price attributes.

If two items are on the same x-aisle, the shortest distance from one to the other is the absolute value of the difference between their y-coordinates. We then divide the distance by the contestant's speed, 10 feet/second to convert this calculation to time.

If two items are on different x-aisle, the shortest distance from one to the other is either by moving up to the end of the aisle, across to the other item's aisle, and then down to the item, or by moving down to the start of the aisle, across to the other item's aisle, and then up to the item. An algorithm should choose the shortest of these two options, which could be done by taking the minimum of the two or by finding if the two item's y-values on average are closer to the end (110 ft) or the beginning (0 ft). We then divide the distance by the contestant's speed, 10 feet/second to convert this distance to time.

Then two seconds is added to each time between nodes to account for the time it takes for a contestant to pick up the $j^\textrm{th}$ node.

We implemented this in a short nested loop in Python below:
```{r, eval=FALSE}
# initialize an empty two-dimensional list
d = [[0 for i in range(len(item_list))] for i in range(len(item_list))]
# iterate through all item objects twice for all pairings
for i in range(len(item_list)):
    for j in range(len(item_list)):
        item_i = item_list[i]
        item_j = item_list[j]

        # if item i and j share an aisle:
        if item_i.x == item_j.x:
            d[i][j] = abs(item_i.y - item_j.y) / 10
        # if they don't share an aisle:
        else:
            dist_x = abs(item_i.x - item_j.x)
            dist_y = min(((110 - item_i.y) + (110 - item_j.y) ), item_i.y + item_j.y)
            d[i][j] = (dist_x + dist_y) / 10
        # add 2 seconds to the time between items if the time is not already 0. this creates an extra
        # two seconds for the contestant to pick up the item
        if i!=j:
            d[j][i]+=2
            d[i][j] +=2
```
Then, since the end node we create later doesn't have an entry in the list of items, we duplicate the first row and column of the matrix to the last row and column since the end node is the same as the start node, which exists as the first item in the item list shown. If we previously added 2 to one of these entries, we want to remove it since the last node does not represent an item that needs time for collecting.
```{r, eval=FALSE}
d.append(d[0])
for i in range(len(d[0])):
    if i in [0, len(d[0])-1]:
        d[i].append(d[i][0])
    else:
        d[i].append(d[i][0] - 2)
```



# b.
## Data Placeholders:

$n$ represents the number of nodes, with node 1 being the start node, nodes 2,3,...,n being item nodes, and n+1 being the end node which shares the attributes of the start node.

$T$ represents the maximum time the contestant is given to shop.

$C$ represents the maximum amount of items the contestant can put in their cart.

$v_{i}$ represents the value of node $i$. $\forall i = 1, 2, ..., n$

$d_{ij}$ represents the minimum time it takes to move from node $i$ to node $j$. If node $j$ represents an item and not a start/end point, it will include the 2 seconds to add that item to the cart. $\forall i = 1, 2, ..., n$ $\forall j = 2, 3, ..., n+1$

## Decision Variables:

$x_{ij} = 1$ if node $j$ follows node $i$ in the chosen path, 0 otherwise. $\forall i = 1, 2, ..., n$ $\forall j = 2, 3, ..., n+1$

$y_{j} = 1$ if node $j$ follows node $i$ in the chosen path, 0 otherwise. $\forall j = 1, 2, ..., n+1$

$t_{ij} = y_{j}$ if node $j$ follows node $i$ in the chosen path, 0 otherwise. $\forall i = 1, 2, ..., n$ $\forall j = 2, 3, ..., n+1$

$$
\begin{aligned}
&\max_{x, y, t} &\textrm{score}&=\sum_{i=1}^nv_i\sum_{j=2}^{n+1}x_{ij} \\ \\
\textrm{s.t.}\ \ \ \ \ \ \ \ \ \ \ \ \ (1)&& y_1 &= 0 \\ \\
(2)&&\sum_{j=2}^{n+1}x_{1,j}&=1 \\ \\
(3)&&\sum_{j=2}^{n+1}x_{ij}&\le1 &\forall i=2, 3, ..., n \\ \\
(4)&&\sum_{i=1}^{n}x_{ij}&\le1 &\forall j=2, 3 ..., n\\ \\
(5)&&\sum_{i=1}^{n}x_{i,n+1}&=1 \\ \\
(6)&&t_{ij}&\le T x_{ij} &\forall i = 1, 2, ..., n \ \ \ \ \ \ &\forall j=2, 3, ..., n+1 \\ \\
(7)&&y_j &= \sum_{i=1}^n t_{ij} &\forall j=2, 3, ..., n+1 \\ \\
(8)&&\sum_{k=2}^{n+1} t_{jk} &= y_j + \sum_{k=2}^{n+1} d_{jk}x_{jk} &\forall j=1, 2, ..., n \\ \\
(9)&&x_{ii} &= 0 &\forall i = 1, 2, ..., n \\ \\
(10)&&\sum_{i=1}^{n}x_{ij}&= \sum_{k=2}^{n+1}x_{jk}  &\forall j=2, 3, ..., n \\ \\
(11)&&\sum_{i=1}^n\sum_{j=2}^{n}x_{ij} &\le C \\ \\
&&x_{ij} &\in \{0,1\} &\forall i = 1, 2, ..., n \ \ \ \ \ \ &\forall j=2, 3, ..., n+1 \\ \\
&&t_{ij} &\ge 0 &\forall i = 1, 2, ..., n \ \ \ \ \ \ &\forall j=2, 3, ..., n+1 \\ \\
\end{aligned}
$$

## Constraint Explanations:

(1) The path begins at node 1 with a time of 0.

(2) Node 1 has exactly one destination node directly after it in the path.

(3) Nodes 2 through $n$ may have at most one destination node directly after it in the path.

(4) Nodes 2 through $n$ may have at most one origin node directly before it in the path.

(5) Node n+1 has exactly one origin node directly before it in the path.

(6) If the direct path from node $i$ to node $j$ exists, than $t_ij$ is upper bounded at $T$. Otherwise, it is constrained to equal 0.

(7) Each running time $y_j$ is set as the sum over all $i$ of $t_ij$ for all destination nodes $j$, of which at most one is nonzero.

(8) We define the sum over destination nodes $k$ of $t_jk$ as the sum of the running total at node $j$ plus the additional time added by the chosen destination.

(9) No node may follow itself in the path.

(10) Nodes that are not entered may not be exited, and nodes that are entered must be exited.

(11) The amount of item nodes in the path must be less than $C$.

# c.
Path Taken:
Node 1: Start Node (0,0)

Node 2: Coffee Beans: $6.99 at (0,15)

Node 3: K-Cups: $10.99 at (0,35)

Node 6: Granola: $5.49 at (0,100)

Node 26: Shampoo: $8.99 at (40,100)

Node 31: Trash Bags: $8.99 at (50,95)

Node 36: Air Freshner: $6.99 at (60,75)

Node 35: Dog Treats: $3.99 at (60,65)

Node 34: Broom: $13.99 at (60,35)

Node 33: Detergent: $12.99 at (60,20)

Node 40: Redbull (4): $7.99 at (70,30)

Node 39: Gatorade (12): $6.99 at (70,35)

Node 28: Paper Towels: $9.99 at (50,25)

Node 27: Toilet Paper: $7.99 at (50,15)

Node 22: Ibuprofen: $5.49 at (40,20)

Node 23: Diapers: $25.99 at (40,35)

Back to Start (0,0)

The total value of the optimized cart is $143.85

# d.

```{r, echo=FALSE}
d_results = c(135.64999999999998, 136.64999999999998, 136.85, 136.85, 138.14999999999998, 138.64999999999998, 139.85, 142.35, 143.64999999999998, 143.64999999999998, 143.85, 144.04999999999998, 144.35, 145.64999999999998, 148.64999999999998, 148.64999999999998, 148.85, 149.64999999999998, 150.35, 150.35, 151.64999999999998)
times=c(80:100)
plot(times, d_results, col="dark green", xlab="Number of seconds allotted to competitors (seconds)", ylab="Optimal value ($)", type='o')
```

# e.

```{r, echo=FALSE}
e_results=c(73.95, 83.94, 92.92999999999999, 101.91999999999999, 110.90999999999998, 118.89999999999998, 125.88999999999997, 132.87999999999997, 138.36999999999998, 140.05999999999997, 143.85, 147.64, 147.82999999999998, 148.82, 148.82, 148.82, 148.82, 148.82, 148.82, 148.82, 148.82)
capacities=c(5:25)
plot(capacities, e_results, col="blue", xlab="Maximum Number of Items Allowed In Cart", ylab="Optimal value ($)", type='o')
```

# f.

```{r, echo=FALSE}
f_results=c(49.4259250164032,51.06009101867676,48.211241006851196,48.72215414047241,48.386127948760986,48.28911089897156,47.09932589530945,35.00831413269043,8.069560050964355,0.9056010246276855,0.8977799415588379)
f_results=c(49.04923486709595,48.49178385734558,48.616859912872314,49.12479591369629,52.22806119918823,52.664852142333984,52.3493549823761,52.59743309020996,51.506157875061035,52.76315999031067,47.340734004974365,35.65971803665161,8.650303840637207,1.0945320129394531,1.0121819972991943)
mipgaps=c(0.00001,0.00005,0.0001,0.0005,0.001,0.005,0.01,0.05,0.1,0.5,1)
mipgaps=c(0.0000001,0.0000005,0.000001,0.000005,0.00001,0.00005,0.0001,0.0005,0.001,0.005,0.01,0.05,0.1,0.5,1)
#mipgaps2=c(-4,)
plot(log(mipgaps,base=10), f_results, col="purple", xlab="log(MIP Gaps)", ylab="Runtime (seconds)", type='o')
```

