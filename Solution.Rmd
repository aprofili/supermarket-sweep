---
title: "Supermarket Sweep"
author: "Adam Profili, Brynn Schneberger"
date: "4/25/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# a.

We start first with a list of the nodes given in the Supermarket Sweep.csv file, each wrapped in an Item object that holds its x, y, and price attributes.

If two items are on the same x-aisle, the shortest distance from one to the other is the absolute value of the difference between their y-coordinates. We then divide the distance by the contestant's speed, 10 feet/second to convert this calculation to time.

If two items are on different x-aisle, the shortest distance from one to the other is either by moving up to the end of the aisle, across to the other item's aisle, and then down to the item, or by moving down to the start of the aisle, across to the other item's aisle, and then up to the item. An algorithm should choose the shortest of these two options, which could be done by taking the minimum of the two or by finding if the two item's y-values on average are closer to the end (110 ft) or the beginning (0 ft). We then divide the distance by the contestant's speed, 10 feet/second to convert this distance to time.

Then two seconds is added to each time between nodes to account for the time it takes for a contestant to pick up the $j^\textrm{th}$ node.

We implemented this in a short nested loop in Python below:
```{r, eval=FALSE}
# initialize an empty two-dimensional list
d = [[0 for i in range(len(item_list))] for i in range(len(item_list))]
# iterate through all item objects twice for all pairings
for i in range(len(item_list)):
    for j in range(len(item_list)):
        item_i = item_list[i]
        item_j = item_list[j]

        # if item i and j share an aisle:
        if item_i.x == item_j.x:
            d[i][j] = abs(item_i.y - item_j.y) / 10
        # if they don't share an aisle:
        else:
            dist_x = abs(item_i.x - item_j.x)
            dist_y = min(((110 - item_i.y) + (110 - item_j.y) ), item_i.y + item_j.y)
            d[i][j] = (dist_x + dist_y) / 10
        # add the extra time to pick up node j 
        if i!=j:
            d[j][i]+=2
            d[i][j] +=2
```
Then, since the end node we create later doesn't have an entry in the list of items, we duplicate the first row and column of the matrix to the last row and column since the end node is the same as the start node, which exists as the first item in the item list shown. If we previously added 2 to one of these entries, we want to remove it since the last node does not represent an item that needs time for collecting.
```{r, eval=FALSE}
d.append(d[0])
for i in range(len(d[0])):
    if i in [0, len(d[0])-1]:
        d[i].append(d[i][0])
    else:
        d[i].append(d[i][0] - 2)
```



# b.
## Data Placeholders:

$n$ represents the number of nodes, with node 1 being the start node, nodes 2,3,...,n being item nodes, and n+1 being the end node which shares the attributes of the start node.

$T$ represents the maximum time the contestant is given to shop.

$C$ represents the maximum amount of items the contestant can put in their cart.

$v_{i}$ represents the value of node $i$. $\forall i \in [\![1, n]\!]$

$d_{ij}$ represents the minimum time it takes to move from node $i$ to node $j$. If node $j$ represents an item and not a start/end point, it will include the 2 seconds to add that item to the cart. $\forall i = 1, 2, ..., n$ $\forall j \in [\![2, n+1]\!]$

## Decision Variables:

$x_{ij} = 1$ if node $j$ follows node $i$ in the chosen path, 0 otherwise. $\forall i \in [\![1, n]\!]$ $\forall j \in [\![2, n+1]\!]$

$y_{j}$ represents the running time to follow the path from the start until node $j$. $\forall j \in [\![1, n+1]\!]$

$t_{ij} = y_{j}$ if node $j$ follows node $i$ in the chosen path, 0 otherwise. $\forall i \in [\![1, n]\!]$ $\forall j \in [\![2, n+1]\!]$

$$
\begin{aligned}
&\max_{x, y, t} &\textrm{score}&=\sum_{i=1}^nv_i\sum_{j=2}^{n+1}x_{ij} \\ \\
\textrm{s.t.}\ \ \ \ \ \ \ \ \ \ \ \ \ (1)&& y_1 &= 0 \\ \\
(2)&&\sum_{j=2}^{n+1}x_{1,j}&=1 \\ \\
(3)&&\sum_{j=2}^{n+1}x_{ij}&\le1 &\forall i \in [\![2, n]\!] \\ \\
(4)&&\sum_{i=1}^{n}x_{ij}&\le1 &\forall j \in [\![2, n]\!]\\ \\
(5)&&\sum_{i=1}^{n}x_{i,n+1}&=1 \\ \\
(6)&&t_{ij}&\le T x_{ij} &\forall i \in [\![1, n]\!] \ \ \ \ \ \ &\forall j \in [\![2, n+1]\!] \\ \\
(7)&&y_j &= \sum_{i=1}^n t_{ij} &\forall j \in [\![2, n+1]\!] \\ \\
(8)&&\sum_{k=2}^{n+1} t_{jk} &= y_j + \sum_{k=2}^{n+1} d_{jk}x_{jk} &\forall j \in [\![1, n]\!] \\ \\
(9)&&x_{ii} &= 0 &\forall i \in [\![1, n]\!] \\ \\
(10)&&\sum_{i=1}^{n}x_{ij}&= \sum_{k=2}^{n+1}x_{jk}  &\forall j \in [\![2, n]\!] \\ \\
(11)&&\sum_{i=1}^n\sum_{j=2}^{n}x_{ij} &\le C \\ \\
&&x_{ij} &\in \{0,1\} &\forall i \in [\![1, n]\!] \ \ \ \ \ \ &\forall j \in [\![2, n+1]\!] \\ \\
&&t_{ij} &\ge 0 &\forall i \in [\![1, n]\!] \ \ \ \ \ \ &\forall j \in [\![2, n+1]\!] \\ \\
\end{aligned}
$$

## Constraint Explanations:

(1) The path begins at node 1 with a time of 0.

(2) Node 1 has exactly one destination node directly after it in the path.

(3) Nodes 2 through $n$ may have at most one destination node directly after it in the path.

(4) Nodes 2 through $n$ may have at most one origin node directly before it in the path.

(5) Node n+1 has exactly one origin node directly before it in the path.

(6) If the direct path from node $i$ to node $j$ exists, than $t_ij$ is upper bounded at $T$. Otherwise, it is constrained to equal 0.

(7) Each running time $y_j$ is set as the sum over all $i$ of $t_ij$ for all destination nodes $j$, of which at most one is nonzero.

(8) We define the sum over destination nodes $k$ of $t_jk$ as the sum of the running total at node $j$ plus the additional time added by the chosen destination.

(9) No node may follow itself in the path.

(10) Nodes that are not entered may not be exited, and nodes that are entered must be exited.

(11) The amount of item nodes in the path must be less than $C$.

# c.

Path Taken:

Node 1: Start Node (0,0)

Node 2: Coffee Beans: $6.99 at (0,15)

Node 3: K-Cups: $10.99 at (0,35)

Node 6: Granola: $5.49 at (0,100)

Node 26: Shampoo: $8.99 at (40,100)

Node 31: Trash Bags: $8.99 at (50,95)

Node 36: Air Freshner: $6.99 at (60,75)

Node 35: Dog Treats: $3.99 at (60,65)

Node 34: Broom: $13.99 at (60,35)

Node 33: Detergent: $12.99 at (60,20)

Node 40: Redbull (4): $7.99 at (70,30)

Node 39: Gatorade (12): $6.99 at (70,35)

Node 28: Paper Towels: $9.99 at (50,25)

Node 27: Toilet Paper: $7.99 at (50,15)

Node 22: Ibuprofen: $5.49 at (40,20)

Node 23: Diapers: $25.99 at (40,35)

Back to Start (0,0)

The total value of the optimized cart is $143.85

# d.

For this question, we were asked to observe the change in optimal value as we increased the time that the contestants are allowed to shop for. We see from the graph that the optimal value increases as we increase the allotted time that customers can shop for. This makes sense because customer will have more time to pick up the fifteen most expensive items instead of being limited by the time consraint. The fifteen most expensive item will give the optimal value of $154.85 which we can see is the optimal value starting at 110 seconds. We decided to plot every 5 seconds because the value were a little varied from the linear line which we expect because the prices of the items do not allow for the line to be linear and the values of the items in the cart are dependent on a binary decision: We can either include the item or not. As we see from the graphs, the optimal value is increasing steadily and then plateaus, indicating that the function of optimal value verses allotted seconds is a concave increasing function.
```{r, echo=FALSE}
d_results = c(86.42, 94.41999999999999, 101.69999999999999, 112.67999999999999, 119.67999999999996, 128.66999999999996, 135.64999999999998, 138.64999999999998, 143.85, 148.64999999999998, 151.64999999999998, 153.85, 154.85, 154.85, 154.85, 154.85, 154.85)
times=50+(0:16)*5
plot(times, d_results, col="dark green", xlab="Number of seconds allotted to competitors (seconds)", ylab="Optimal value ($)", type='o')
```

# e.

For this part of the problem we were asked to compare the changes in optimal value as we changed the maximum number of items allowed in the contestant's cart. We observed this change while keeping the time to complete the sweep constant, at 90 seconds. As shown in the graph, the optimal value of the items in the shopping cart increases until the capacity of the cart is 18. At this point, the optimal value of the items in the cart plateaus because the contestant does not have the time to go around the store and pick up all of the expensive items. It appears that the most money they can make during a 90 second interval is $148.82. The function of the optimal value on the number of items allowed in the cart is a concave increasing function. 

```{r, echo=FALSE}
e_results=c(73.95, 83.94, 92.92999999999999, 101.91999999999999, 110.90999999999998, 118.89999999999998, 125.88999999999997, 132.87999999999997, 138.36999999999998, 140.05999999999997, 143.85, 147.64, 147.82999999999998, 148.82, 148.82, 148.82, 148.82, 148.82, 148.82, 148.82, 148.82)
capacities=c(5:25)
plot(capacities, e_results, col="blue", xlab="Maximum Number of Items Allowed In Cart", ylab="Optimal value ($)", type='o')
```

# f.

For part f, we were asked to observe the change in runtime as we change the MIPGap parameter. This parameter helps determine when the optimizing function can terminate by giving a maximum relative percent difference in optimal values. As we changed this parameter while keeping the cart capacity and allotted time constant, we observe a decrease in the run time, measured in seconds. We decided to preform a log base 10 transformation of the MIPGap to show the data better on the graph. The graph shows that as we increase the MIPGap parameter, the time to solve the problem drastically decreases from a value consistently within the 45 to 50 second range all the way down to 1 second. We can see that the graph would continue to be between 0 and 1 as we increase the MIPGap. While this graph is neither concave or conex, it is a decreasing function, indicating that as we increase the MIPGap, the run time decreases. 

```{r, echo=FALSE}
f_results=c(55.552918910980225,51.73050308227539,49.226829051971436,48.2147171497345,46.99422883987427,40.8342010974884,35.21365284919739,7.805516004562378,0.9036610126495361,0.8991899490356445,0.8945901393890381)
mipgaps=c(10**-5,10**-4,10**-3,5*10**-3,10**-2,10**-(5/3),10**-(4/3),10**-1,10**-(2/3),10**-(1/3),10**0)
#mipgaps2=c(-4,)
plot(log(mipgaps,base=10), f_results, col="purple", xlab="log(MIPGap)", ylab="Runtime (seconds)", type='o')
```

